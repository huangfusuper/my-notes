entriesToAddOnCommit

entriesMissedInCache防止缓存穿透


事实上第一次查询，会直接查询二级缓存，如果二级缓存没有数据，会查询数据库，将数据查询出来之后，填充到暂存区注意：此时还没有填充到二级缓存区域的

执行commit操作后会刷新暂存区到二级缓存区域，什么是刷新暂存区，无非是遍历暂存区，然后将数据全部写到二级缓存的区域然后将二级缓存对应的暂存区清空
    这么做的用意是什么，其实仅仅是为了避免脏数据，试想一下，如果灭有暂存区空间会有什么情况发生？假设发生了一个写操作，执行完成后另外一个请求查询到了该
    数据直接放置到二级缓存区域，但是此时这条数据执行了回滚操作，那么此时就会造成一个脏读！再或者一个修改操作，修改完数据后，将二级缓存清空，但是此时数据异常，发生回滚！事实上，数据没有修改成功，
    我们是不应该去清空二级缓存的，这是不应该的！

所以修改成功后，也并不会立即清空二级缓存，二十做了一个提交清空的标记，只有再提交的时候，判断这个标记执行清空，这样就能够避免因为回滚造成的误清空的操作！

事实上，我对暂存区的理解是保存SqlSession在事务中需要向某个二级缓存提交的缓存数据因为事务过程中的数据可能会回滚，所以不能直接把数据就提交二级缓存，
    而是暂存在TransactionalCache中，在事务提交后再将过程中存放在其中的数据提交到二级缓存，如果事务回滚，则将数据清除掉
